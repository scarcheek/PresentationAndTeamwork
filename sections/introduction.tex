Refactoring, as defined by Fowler\cite{fowler2018refactoring}, is “the process of changing a software system in such a way that does not alter the external behaviour of the code yet improves its internal structure”. More and more empirical studies have since established a positive correlation between refactoring operations and code quality metrics. All this evidence hints at refactoring being a high-priority concern for software engineers.\cite{aniche2020effectiveness}.\\
However, deciding when and how to refactor can prove to be a challenge for developers. Refactoring in an early stage may cost too much for what you're getting out of it, and refactoring too late may cause the refactor to be an even bigger time commitment.\cite{kruchten2012technical}\\
Tools have been in the hands of many developers to make this process more streamlined for years now. Analytics tools to sniff out bugs or give hints on how to improve code quality such as PMD, ESLint, and Sonarqube can be integrated into different stages of a developers' workflow, e.g. inside IDEs, during code review or as an overall quality report. \cite{aniche2020effectiveness}\\
Taking a closer look at these tools, however, reveals that they commonly have a lot of false positives, making developers lose their confidence in them. Often, the detection strategies are based on hard thresholds of just a handful of metrics, such as lines of code in a file (e.g. PMD's famous "problematic" classification occurring once a method reaches 100 lines per default). These simplistic ways of detection simply aren't able to capture the full complexity of modern software systems.\\
Manually analyzing hundreds of metrics and figuring out which ones are the cause of technical dept is very hard and almost impossible for tool developers, which is where machine learning-based solutions come into play.\cite{kataoka2002refactoring}\cite{leitch2003maintainability}\\
We will take a closer look at how exactly different models go about this task in section \ref{benefits}
